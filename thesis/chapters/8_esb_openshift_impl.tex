\chapter{Implementation ESB in Openshift}
\label{cha:esbi}
This chapter will discuss the implemented prototype, which has been designed in Chapter \vref{cha:esboc}. The implemented prototype uses a lot of technologies and specifications, which are beyond the scope of tis thesis, therefore this thesis will focus on the most important implementation parts. A focus will be set on the implementation of the aspects discussed in Section \vref{sec:esboc-aspects}, which ensure that a integration service can be managed properly in a Openshift Cluster. 
\\ \\
The integration services are implemented as microservice, which run as standalone applications on the Openshift Cluster, with their own life cycle. The integration services communicate via REST with each other, whereby each service provides a proper managed public API. The code bases of the integration services are managed separately, which completely de-couples the integration service from each other.  
\\ \\
As the prototype illustrates, the ESB is now represented by Openshift, which acts as the platform for the hosted integration services. The hosted integration services are implemented as microservices and are running in Docker Containers as standalone applications. Horizontal scaling and the distribution of the services over multiple hosts are now possible. Section \vref{sec:esbi-openshift} will discuss the implemented Openshift resources, which are used to define and manage the Openshift Project.
\\ \\
Is is assumed, that the reader is familiar with Java Enterprise Development, Maven and microservices. The implemented prototype is available on Github \footnote{https://github.com/cchet-thesis-msc/prototype}. The repository contains a README file, which describes how to setup the prototype. 

\section{Microservice Technologies}
\label{sec:esbi-technolody-fis}
The following sections will give a brief introduction about the most important technologies used to implement the integration services. Each implemented service uses the same technologies and is build the same way, because no matter what the concrete purpose of the service is, they all have to be integrated and run the same way on a Openshift Cluster.

\subsection{JBoss Fuse Integration Services 2.0}
\label{sec:esbi-technology-fis}
JBoss Fuse Integration Services 2.0 is a set of tooling for developing integration services running on a Openshift Cluster. It provides Openshift integrations for different frameworks such as Spring Boot, Karaf or Camel. The services are started via an Java-Agent such as Prometheus or Jolokia, which are used to monitor the service during runtime. Additionally to provided Openshift resources, a Maven Plugin is provided, which allows to interact with the Openshift Cluster during a Maven build. JBoss Fuse Integration Services 2.0 allows developers to interact with a Openshift Cluster in a way like developers did before with an application server \cite{Prometheus2018, Jolokia2018}.

\subsection{Wildfly Swarm}
\label{sec:esbi-technology-swarm}
Wildly Swarm is the JEE answer to Spring Boot, and is a framework, which allows to package an application into an Uber-JAR. An Uber-JAR is a packaged standalone application, which can be started with the command \inlineJava{java -jar}. During the packaging, only those components of an application server are packaged, which are referenced and needed by the application. The application can then be started via \inlineBash{java -jar app.jar}, whereby the application server is bootstrapped programmatically.  The application deployment artifact is a JAVA Web-Archive, which could be hosted in any application server environment, which provides all of the referenced dependencies \cite{WildflySwarm2018}. 

\subsection{Fabric8}
\label{sec:esbi-technology-f8}
Fabric8 is an integrated development platform for developing applications on Kubernetes. Fabric8 provides the Maven Plugin for the JBoss Fuse Integration Services 2.0, and focuses on building Docker Images, managing Kubernetes or Openshift resources and deploying Java applications on Kubernetes or Openshift Clusters \cite{Fabric82018}.
\\ \\
The next Section will discuss the implementations of the microservice aspects discussed in Section \vref{sec:esboc-aspects}.

\section{Security}
\label{sec:esbi-security}
The integration services are secured with OAuth, and authenticate their clients via Keycloak. Keycloak is used as the authentication service, and is a very popular open source identity and authentication application. Wildfly Swarm provides an integration into Keycloak via the Keycloak-Adapter, which only needs to be added as a dependency to the Maven POM and to be configured.

\subsection{Service Implementation}
\label{sec:esbi-security-service}
This section will discuss the implementation of the security in the service implementations. Listing \vref{ls:esboi-security-pom} shows the dependency, which brings in the Keycloak Adapter, integrates itself into the Java Web-Security mechanisms, and can therefore be configured with Java Web-Security security constraints.
\begin{listing}
	\xmlFile{\sourceDir/maven-keycloak-swarm.xml}
	\caption{Wildfly Swarm Keycloak dependency in pom.xml}
	\label{ls:esboi-security-pom}
\end{listing}

Listing \vref{ls:esboi-security-yaml} shows an excerpt of the Wildfly Swarm configuration file project-stages.yml, which configures the security constraints for the REST-Endpoint.

\begin{listing}
	\yamlFile{\sourceDir/project-stages-security.yml}
	\caption{Security configuration in project-stages.yml}
	\label{ls:esboi-security-yaml}
\end{listing}

The following two listings are excerpts of the deployment.yml Openshift Template, which is managed in the service code base. Listing \vref{ls:esboi-security-oc-deployment-volume-secret} shows the specification of the secret injection into a Docker Volume. The secrets are injected as files, whereby the file name represents the secret key and the file content represents the secret value. Therefore, that the secrets are managed externally, the developers need to provide the secret name for the service deployment configuration. In this case an expression is used, which can be replaced by Maven Properties, whereby the Maven Properties can be provided in the pom.xml or provided/overwritten by Java Options, during the build process.

\begin{listing}
	\yamlFile{\sourceDir/deployment-volume-secret.yml}
	\caption{Configuration of the secret injection}
	\label{ls:esboi-security-oc-deployment-volume-secret}
\end{listing}

Listing \vref{ls:esboi-security-oc-deployment-volume-mount} show the specification of the mount of the Docker Volume, which provides the secrets. The mount path is also represented by a Maven Property, because this path is also used in the project-stages.yml file, where it points to the service configuration source for the productive stage. The secrets consumed by the services are used the same way as non-sensitive configurations, which are discussed in Section \vref{sec:esbi-configuration}.

\begin{listing}
	\yamlFile{\sourceDir/deployment-volume-secret-container.yml}
	\caption{Configuration volume mount}
	\label{ls:esboi-security-oc-deployment-volume-mount}
\end{listing}

\subsection{Openshift Implementation}
\label{sec:esbi-security-openshift}
This section will discuss the Openshift implementation, whereby the implementation is represented by a shell script, which manages the secrets. The secrets are managed outside the code bases of the integration services.
\\ \\
Listing \vref{ls:esboi-security-oc-secret} shows the Openshift CLI-Command, which is used to create the secrets. The secrets are consumed by the service application, which needs to perform authentication against the integration service and needs to know where the integration service and the authentication service are located. 

\begin{listing}
	\bashFile{\sourceDir/bash-oc-secret.txt}
	\caption{Openshift CLI command for creating the secret}
	\label{ls:esboi-security-oc-secret}
\end{listing}

The discussed implementations are the necessary implementations on the service and Openshift side, to secure services hosted on a Openshift Cluster. No infrastructure code is necessary, only configuration. The following section will discuss the configuration of the integration services, which can be applied to the security as well, because secrets in Openshift are used in the service implementation the same way as configuration parameters.

\section{Configuration}
\label{sec:esbi-configuration}
The service uses the MicroProfile Config-API and the implementation provided by Wildfly Swarm to define used configuration source for the different stages and to inject configurations into service implementations. The developers are only bound to the usage, key and value type, but developers are not bound to the configuration source, which allows to provide the configurations from different sources for different stages. 

\subsection{Service Implementation}
\label{sec:esbi-config-service}
This section will discuss the service implementation of the usage of the MicroProfile Config-API, and of the configuration for the configuration source for the different stages.  

\begin{listing}
	\xmlFile{\sourceDir/maven-microprofile-config.xml}
	\caption{Wildfly Swarm MicroProfile-Config dependency in pom.xml}
	\label{ls:esboi-config-pom}
\end{listing}

Listing \vref{ls:esboi-config-pom} shows the Wildfly swarm MicroProfile-Config dependency, which brings in all needed integrations into Wildfly Swarm, so that developers can configure configuration sources and inject configuration properties.

\begin{listing}
	\bashFile{\sourceDir/project-stages-micro-config-dev.yml}
	\caption{Hard coded configuration for development}
	\label{ls:esboi-config-project-stages-dev}
\end{listing}

Listing \vref{ls:esboi-config-project-stages-dev} shows the configuration of the configuration source with the name \mentionedtext{app.secrets} for the development stage, whereby the configuration properties are provided hard coded.
\newpage

\begin{listing}
	\yamlFile{\sourceDir/project-stages-micro-config-prod.yml}
	\caption{Hard coded configuration for production}
	\label{ls:esboi-config-project-stages-prod}
\end{listing}

Listing \vref{ls:esboi-config-project-stages-prod} shows the configuration of the configuration source with the name \mentionedtext{app.secrets} for the production stage, whereby the configurations are loaded via a directory. The directory location is represented by an Maven Property, because its used in multiple configuration files, as already discussed in Section \vref{sec:esbi-security-service}.


\begin{listing}
	\javaFile{\sourceDir/java-config-inject.java}
	\caption{Injection of Keycloak configuration parameters}
	\label{ls:esboi-config-inject}
\end{listing}

Listing \vref{ls:esboi-config-inject} shows the injection of the Keycloak secrets, which are used to retrieve an token for the token based authentication of the rest client calls. The configuration properties are actual secrets, which the developers does not see when injecting, it because the developers do not have access to the underlying configuration source.

\subsection{Openshift Implementation}
\label{sec:esbi-config-openshift}
The Openshift implementation is already covered by Section \vref{sec:esbi-security-openshift}, because all of the configuration parameters are managed as secrets. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









\section{Tracing}
\label{sec:esbi-tracing}

\subsection{Service Implementation}
\label{sec:esbi-tracing-service}

\subsection{Openshift Implementation}
\label{sec:esbi-tracing-openshift}

\section{Logging}
\label{sec:esbi-logging}

\subsection{Service Implementation}
\label{sec:esbi-logging-service}

\subsection{Openshift Implementation}
\label{sec:esbi-logging-openshift}

\section{Fault Tolerance}
\label{sec:esbi-fault}

\subsection{Service Implementation}
\label{sec:esbi-fault-service}

\subsection{Openshift Implementation}
\label{sec:esbi-fault-openshift}

\section{API Management}
\label{sec:esbi-api}

\subsection{Service Implementation}
\label{sec:esbi-api-service}

\subsection{Openshift Implementation}
\label{sec:esbi-api-openshift}

\section{Openshift Project}
\label{sec:esbi-openshift}

\subsection{Configuration}
\label{sec:esbi-openshift-config}

\subsection{Secrets}
\label{sec:esbi-openshift-secrets}

