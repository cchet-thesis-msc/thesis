\chapter{Implementation ESB in Openshift}
\label{cha:esbi}
This chapter will discuss the implementation of the prototype, which has been specified in Chapter \vref{cha:esboc}. The prototype is hosted in a single Openshift Project, where Openshift acts as the ESB, which provides features as discussed in Section \vref{sec:paas-openshift-project}. As discussed in Section \vref{sec:esb-liwest-esb}, an ESB application running in JBoss Fuse, runs in a single runtime environment, which hosts all of the service components. Therefore, the ESB can only be scaled vertically and the ESB represents a single point of failure. If the runtime environment fails, the whole ESB application fails.
\\ \\
As the prototype illustrates, the ESB is now represented by Openshift, which acts now as the \mentionedtext{runtime environment} for the hosted services. But, Openshift is not the runtime environment anymore, but is the platform for the runtime environment of the hosted services. The hosted services are now running in Docker Containers as standalone applications. Horizontal scaling and the distribution of the services over multiple hosts are now possible. Section \vref{sec:esbi-openshift} will discuss the implementation of the Openshift Project hosting the prototype.
\\ \\
The services run as standalone applications on the ESB, with their own life cycle. But organizing the services separately, increases the development overhead compared to a monolithic ESB application. Within a monolithic code base redundancies can be avoided by extracting common code to a module, which can for instance be done with models and utilities. Changes made on the common source code will immediately affect all referencing source code. Independent services, which for instance communicate via REST, are completely decoupled from each other, where the REST-API is the only dependency of an service. Section \vref{sec:esbi-api} will discuss the importance of API-Management and will describe ways how to implement a REST-API migration.

\section{Technology}
\label{sec:esbi-technolody-fis}
The following sections will give a brief introduction about the most important technologies used by the implemented services. Each implemented service use the same technologies and they are setup the same way, because no matter what the concrete purpose of the service is, they all have to be integrated and run the same way on Openshift.

\subsection{JBoss Fuse Integration Services 2.0}
\label{sec:esbi-technology-fis}
JBoss Fuse Integration Services 2.0 is a set of tooling for developing integration services for Openshift. It provides Docker Images for different frameworks such as Spring Boot, Karaf or Camel and the services are started via an Java-Agent such as Prometheus or Jolokia, which provide data for an integrated Java-Console in Openshift, which gives an deep insight into the running service \cite{Prometheus2018, Jolokia2018}.

\subsection{Wildfly Swarm}
\label{sec:esbi-technology-swarm}
Wildly Swarm is the JEE answer to Spring Boot, and is an framework, which allows to package an application into an Uber-JAR. During the packaging, only those components of the Wildfly application server are packaged, which are referenced and needed by the application. The application can then be started via \inlineBash{java -jar app.jar}, whereby the contained Wildfly application server is bootstrapped programmatically.  The application deployment artifact is a JAVA Web-Archive, which could be hosted in any application server environment, which provides all of the referenced dependencies. 

\subsection{Fabric8}
\label{sec:esbi-technology-f8}
Fabric8 is an open source project under the umbrella of RedHat, which is an integrated development platform for developing applications on Kubernetes. Fabric8 also provides a maven plugin, which focus on building Docker Images, managing Kubernetes or Openshift resources and deploying Java applications on Kubernetes or Openshift, and it is part of JBoss Fuse Integration Services 2.0.

\section{Security}
\label{sec:esbi-security}
The access to the integration service is secured with OAuth. Keycloak is used as the authentication service, which is a very popular open source identity and authentication application. Wildfly Swarm provides an integration into Keycloak via the Keycloak-Adapter, which only needs to be added as a dependency and configured.
\\ \\
The secrets needed by the services are managed in Openshift, and no developer has access to them. The developers only know the name of the used secret and its provided keys. The decoupling of the developers from the secrets in productive environments increases security. The secrets can be changed at any time, only a restart of the referencing services is required.

\subsection{Service Implementation}
\label{sec:esbi-security-service}
This section will discuss the implementation of the security in the service implementations, whereby the implementation is represented by the in further discussed configurations. 

\begin{listing}
	\xmlFile{\sourceDir/maven-keycloak-swarm.xml}
	\caption{Wildfly Swarm Keycloak dependency in pom.xml}
	\label{ls:esboi-security-pom}
\end{listing}

Listing \vref{ls:esboi-security-pom} shows the dependency, which brings in the Keycloak Adapter, integrates itself into the Java Web-Security mechanisms, and can therefore be configured with Java Web-Security security constraints.

\begin{listing}
	\yamlFile{\sourceDir/project-stages-security.yml}
	\caption{Security configuration in project-stages.yml}
	\label{ls:esboi-security-yaml}
\end{listing}

Listing \vref{ls:esboi-security-yaml} shows an excerpt of the Wildfly Swarm used project-stage.yml file, which configures the security constraints for the rest endpoint. The secrets consumed by the service are used the same way as non-sensitive configurations, which are discussed in Section \vref{sec:esbi-configuration}.
\\ \\
The following two listings are excerpts of the deployment.yml Openshift Template, which is managed in the service code base.

\begin{listing}
	\yamlFile{\sourceDir/deployment-volume-secret.yml}
	\caption{Configuration of the secret injection}
	\label{ls:esboi-security-oc-deployment-volume-secret}
\end{listing}

Listing \vref{ls:esboi-security-oc-deployment-volume-secret} shows the specification of the secret injection into a Docker Volume. The secrets get injected as files, whereby the file name represents the key and the content represents the value of the secret. Therefore, that the secrets are managed externally, the developers need to provide the secret name for the service deployment configuration. In this case an expression is sued, which can be replaced by Maven properties, whereby the Maven Properties can be provided in the pom.xml or provided/overwritten by Java Options, during the build process.

\begin{listing}
	\yamlFile{\sourceDir/deployment-volume-secret-container.yml}
	\caption{Configuration volume mount}
	\label{ls:esboi-security-oc-deployment-volume-mount}
\end{listing}

Listing \vref{ls:esboi-security-oc-deployment-volume-mount} show the specification of the mount of the Docker Volume, which provides the secrets. The mount path is also represented by a Maven Property, because this path is also used in the project-stages.yml file, where it points to the service configuration source for the productive stage. 

\subsection{Openshift Implementation}
\label{sec:esbi-security-openshift}
This section will discuss the Openshift implementation, whereby the implementation is represented by a shell script, which manages the secrets. 

\begin{listing}
	\bashFile{\sourceDir/bash-oc-secret.txt}
	\caption{Openshift CLI command for creating the secret}
	\label{ls:esboi-security-oc-secret}
\end{listing}

Listing \vref{ls:esboi-security-oc-secret} shows the Openshift CLI-Command, which is used to create the secrets. The secrets are consumed by the service application, which needs to perform authentication against the integration service and needs to know where the integration service and the authentication service are located. 
\\ \\
The next Section \vref{sec:esbi-configuration} will discuss the configuration of the service in an Openshift environment, which for this prototype represents the ESB. The usage of secrets is th same as the usage of configuration properties, because the only difference is the sensitivity of the data. The secrets which have been injected into the container, are read by the runtime configuration mechanism, which exposes them as configuration properties to the service implementation.

\newpage

\section{Configuration}
\label{sec:esbi-configuration}
The service uses the MicroProfile Config-API and the implementation provided by Wildfly Swarm to define used configuration source for the different stages and to inject configurations into service implementations. The developers are only bound to the usage, key and value type, but developers are not bound to the configuration source, which allows to provide the configurations from different sources for different stages. 

\subsection{Service Implementation}
\label{sec:esbi-config-service}
This section will discuss the service implementation of the usage of the MicroProfile Config-API, and of the configuration for the configuration source for the different stages.  

\begin{listing}
	\xmlFile{\sourceDir/maven-microprofile-config.xml}
	\caption{Wildfly Swarm MicroProfile-Config dependency in pom.xml}
	\label{ls:esboi-config-pom}
\end{listing}

Listing \vref{ls:esboi-config-pom} shows the Wildfly swarm MicroProfile-Config dependency, which brings in all needed integrations into Wildfly Swarm, so that developers can configure configuration sources and inject configuration properties.

\begin{listing}
	\bashFile{\sourceDir/project-stages-micro-config-dev.yml}
	\caption{Hard coded configuration for development}
	\label{ls:esboi-config-project-stages-dev}
\end{listing}

Listing \vref{ls:esboi-config-project-stages-dev} shows the configuration of the configuration source with the name \mentionedtext{app.secrets} for the development stage, whereby the configuration properties are provided hard coded.
\newpage

\begin{listing}
	\yamlFile{\sourceDir/project-stages-micro-config-prod.yml}
	\caption{Hard coded configuration for production}
	\label{ls:esboi-config-project-stages-prod}
\end{listing}

Listing \vref{ls:esboi-config-project-stages-prod} shows the configuration of the configuration source with the name \mentionedtext{app.secrets} for the production stage, whereby the configurations are loaded via a directory. The directory location is represented by an Maven Property, because its used in multiple configuration files, as already discussed in Section \vref{sec:esbi-security-service}.


\begin{listing}
	\javaFile{\sourceDir/java-config-inject.java}
	\caption{Injection of Keycloak configuration parameters}
	\label{ls:esboi-config-inject}
\end{listing}

Listing \vref{ls:esboi-config-inject} shows the injection of the Keycloak secrets, which are used to retrieve an token for the token based authentication of the rest client calls. The configuration properties are actual secrets, which the developers does not see when injecting, it because the developers do not have access to the underlying configuration source.

\subsection{Openshift Implementation}
\label{sec:esbi-config-openshift}
The Openshift implementation is already covered by Section \vref{sec:esbi-security-openshift}, because all of the configuration parameters are managed as secrets. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%









\section{Tracing}
\label{sec:esbi-tracing}

\subsection{Service Implementation}
\label{sec:esbi-tracing-service}

\subsection{Openshift Implementation}
\label{sec:esbi-tracing-openshift}

\section{Logging}
\label{sec:esbi-logging}

\subsection{Service Implementation}
\label{sec:esbi-logging-service}

\subsection{Openshift Implementation}
\label{sec:esbi-logging-openshift}

\section{Fault Tolerance}
\label{sec:esbi-fault}

\subsection{Service Implementation}
\label{sec:esbi-fault-service}

\subsection{Openshift Implementation}
\label{sec:esbi-fault-openshift}

\section{API Management}
\label{sec:esbi-api}

\subsection{Service Implementation}
\label{sec:esbi-api-service}

\subsection{Openshift Implementation}
\label{sec:esbi-api-openshift}

\section{Openshift}
\label{sec:esbi-openshift}

\subsection{Configuration}
\label{sec:esbi-openshift-config}

\subsection{Secrets}
\label{sec:esbi-openshift-secrets}

